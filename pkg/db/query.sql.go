// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countQueryTopResultsByKey = `-- name: CountQueryTopResultsByKey :one
SELECT count(tb.value) as count
FROM (
    SELECT result_metadata.value
    FROM result_metadata
    WHERE result_metadata.type_id = (
        SELECT id FROM result_metadata_type WHERE LOWER(value) = LOWER($1::text)
    )
    GROUP BY result_metadata.value
) as tb
`

func (q *Queries) CountQueryTopResultsByKey(ctx context.Context, key string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQueryTopResultsByKey, key)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQueueItems = `-- name: CountQueueItems :one
SELECT count(*) AS count
FROM   queue_item
`

func (q *Queries) CountQueueItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQueueItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAndReturnNode = `-- name: CreateAndReturnNode :one
INSERT INTO node (queue_item_id, name)
VALUES ($1, $2)
RETURNING id, queue_item_id, name
`

type CreateAndReturnNodeParams struct {
	QueueItemID uuid.UUID
	Name        string
}

func (q *Queries) CreateAndReturnNode(ctx context.Context, arg CreateAndReturnNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, createAndReturnNode, arg.QueueItemID, arg.Name)
	var i Node
	err := row.Scan(&i.ID, &i.QueueItemID, &i.Name)
	return i, err
}

const createEdge = `-- name: CreateEdge :exec
INSERT INTO edge (parent_id, child_id)
VALUES ($1, $2)
`

type CreateEdgeParams struct {
	ParentID int32
	ChildID  int32
}

func (q *Queries) CreateEdge(ctx context.Context, arg CreateEdgeParams) error {
	_, err := q.db.ExecContext(ctx, createEdge, arg.ParentID, arg.ChildID)
	return err
}

const createIOSpec = `-- name: CreateIOSpec :exec
INSERT INTO io_spec (node_id, type, node_name, input_id, root, value, path, context)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateIOSpecParams struct {
	NodeID   int32
	Type     IoSpecType
	NodeName string
	InputID  string
	Root     bool
	Value    sql.NullString
	Path     sql.NullString
	Context  sql.NullString
}

func (q *Queries) CreateIOSpec(ctx context.Context, arg CreateIOSpecParams) error {
	_, err := q.db.ExecContext(ctx, createIOSpec,
		arg.NodeID,
		arg.Type,
		arg.NodeName,
		arg.InputID,
		arg.Root,
		arg.Value,
		arg.Path,
		arg.Context,
	)
	return err
}

const createQueueItem = `-- name: CreateQueueItem :exec
INSERT INTO queue_item (id, inputs, created_at)
VALUES ($1, $2, $3)
`

type CreateQueueItemParams struct {
	ID        uuid.UUID
	Inputs    []string
	CreatedAt time.Time
}

func (q *Queries) CreateQueueItem(ctx context.Context, arg CreateQueueItemParams) error {
	_, err := q.db.ExecContext(ctx, createQueueItem, arg.ID, pq.Array(arg.Inputs), arg.CreatedAt)
	return err
}

const createResult = `-- name: CreateResult :exec
INSERT INTO result (node_id, execution_id, stdout, stderr, skipped)
VALUES ($1, $2, $3, $4, $5)
`

type CreateResultParams struct {
	NodeID      int32
	ExecutionID sql.NullString
	Stdout      sql.NullString
	Stderr      sql.NullString
	Skipped     sql.NullBool
}

func (q *Queries) CreateResult(ctx context.Context, arg CreateResultParams) error {
	_, err := q.db.ExecContext(ctx, createResult,
		arg.NodeID,
		arg.ExecutionID,
		arg.Stdout,
		arg.Stderr,
		arg.Skipped,
	)
	return err
}

const createResultMetadata = `-- name: CreateResultMetadata :exec
WITH inserted AS (
    INSERT INTO result_metadata_type(value) VALUES ($2::text)
    ON CONFLICT DO NOTHING
    RETURNING id
)
INSERT INTO result_metadata (queue_item_id, type_id, value)
VALUES (
    $1::uuid, 
    coalesce(
        (select id from inserted),
        (select id from result_metadata_type where value = $2::text)
    ),
    $3::text
)
`

type CreateResultMetadataParams struct {
	QueueItemID uuid.UUID
	Type        string
	Value       string
}

func (q *Queries) CreateResultMetadata(ctx context.Context, arg CreateResultMetadataParams) error {
	_, err := q.db.ExecContext(ctx, createResultMetadata, arg.QueueItemID, arg.Type, arg.Value)
	return err
}

const createStatus = `-- name: CreateStatus :exec
INSERT INTO status (node_id, submitted, started, ended, status)
VALUES ($1, $2, $3, $4, $5)
`

type CreateStatusParams struct {
	NodeID    int32
	Submitted time.Time
	Started   sql.NullTime
	Ended     sql.NullTime
	Status    string
}

func (q *Queries) CreateStatus(ctx context.Context, arg CreateStatusParams) error {
	_, err := q.db.ExecContext(ctx, createStatus,
		arg.NodeID,
		arg.Submitted,
		arg.Started,
		arg.Ended,
		arg.Status,
	)
	return err
}

const getIOSpecByID = `-- name: GetIOSpecByID :one
SELECT id, node_id, type, node_name, input_id, root, value, path, context
FROM io_spec
WHERE id = $1
`

func (q *Queries) GetIOSpecByID(ctx context.Context, id int32) (IoSpec, error) {
	row := q.db.QueryRowContext(ctx, getIOSpecByID, id)
	var i IoSpec
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Type,
		&i.NodeName,
		&i.InputID,
		&i.Root,
		&i.Value,
		&i.Path,
		&i.Context,
	)
	return i, err
}

const getNodeByID = `-- name: GetNodeByID :one
SELECT node.id, node.queue_item_id, node.name, latest_status.submitted, latest_status.started, latest_status.ended, latest_status.status, result.execution_id, result.stdout, result.stderr, result.skipped,
    (SELECT array_agg(DISTINCT io_spec.id)::INT[] AS ids FROM io_spec WHERE io_spec.node_id = $1 AND io_spec.type = 'input') as inputs,
    (SELECT array_agg(DISTINCT io_spec.id)::INT[] AS ids FROM io_spec WHERE io_spec.node_id = $1 AND io_spec.type = 'output') as outputs,
    (SELECT array_agg(DISTINCT edge.parent_id)::INT[] AS ids FROM edge WHERE edge.child_id = $1) as parents,
    (SELECT array_agg(DISTINCT edge.child_id)::INT[] AS ids FROM edge WHERE edge.parent_id = $1) as children
FROM node
FULL OUTER JOIN (
    SELECT id, ts, node_id, submitted, status, started, ended
    FROM status
    WHERE status.node_id = $1
    ORDER BY id DESC LIMIT 1
) as latest_status ON node.id = latest_status.node_id
FULL OUTER JOIN result ON node.id = result.node_id
FULL OUTER JOIN io_spec ON node.id = io_spec.id
FULL OUTER JOIN edge ON node.id = edge.child_id
WHERE node.id = $1
`

type GetNodeByIDRow struct {
	ID          sql.NullInt32
	QueueItemID uuid.NullUUID
	Name        sql.NullString
	Submitted   time.Time
	Started     sql.NullTime
	Ended       sql.NullTime
	Status      string
	ExecutionID sql.NullString
	Stdout      sql.NullString
	Stderr      sql.NullString
	Skipped     sql.NullBool
	Inputs      []int32
	Outputs     []int32
	Parents     []int32
	Children    []int32
}

func (q *Queries) GetNodeByID(ctx context.Context, nodeID int32) (GetNodeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNodeByID, nodeID)
	var i GetNodeByIDRow
	err := row.Scan(
		&i.ID,
		&i.QueueItemID,
		&i.Name,
		&i.Submitted,
		&i.Started,
		&i.Ended,
		&i.Status,
		&i.ExecutionID,
		&i.Stdout,
		&i.Stderr,
		&i.Skipped,
		pq.Array(&i.Inputs),
		pq.Array(&i.Outputs),
		pq.Array(&i.Parents),
		pq.Array(&i.Children),
	)
	return i, err
}

const getNodesByQueueItemID = `-- name: GetNodesByQueueItemID :many
SELECT id, queue_item_id, name
FROM node
WHERE queue_item_id = $1
`

func (q *Queries) GetNodesByQueueItemID(ctx context.Context, queueItemID uuid.UUID) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesByQueueItemID, queueItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(&i.ID, &i.QueueItemID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueItemDetail = `-- name: GetQueueItemDetail :one
SELECT id, inputs, created_at
FROM queue_item
WHERE id = $1
`

func (q *Queries) GetQueueItemDetail(ctx context.Context, id uuid.UUID) (QueueItem, error) {
	row := q.db.QueryRowContext(ctx, getQueueItemDetail, id)
	var i QueueItem
	err := row.Scan(&i.ID, pq.Array(&i.Inputs), &i.CreatedAt)
	return i, err
}

const listQueueItems = `-- name: ListQueueItems :many
SELECT id, inputs, created_at
FROM   queue_item
ORDER BY CASE
    WHEN NOT $1::boolean AND $2::text = 'created_at' THEN created_at
END ASC, CASE
    WHEN $1::boolean AND $2::text = 'created_at' THEN created_at
END  DESC
OFFSET ($3::int - 1) * $4::int
LIMIT  $4::int
`

type ListQueueItemsParams struct {
	Reverse    bool
	Sort       string
	PageNumber int32
	PageSize   int32
}

func (q *Queries) ListQueueItems(ctx context.Context, arg ListQueueItemsParams) ([]QueueItem, error) {
	rows, err := q.db.QueryContext(ctx, listQueueItems,
		arg.Reverse,
		arg.Sort,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueueItem
	for rows.Next() {
		var i QueueItem
		if err := rows.Scan(&i.ID, pq.Array(&i.Inputs), &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const numResultsOverTime = `-- name: NumResultsOverTime :many
SELECT tb.timestamp::timestamp, tb.count, tb.full_count
FROM (
    SELECT
        date_trunc('hour', ts) AS timestamp,
        count(*) AS count,
        count(*) OVER() AS full_count
    FROM
        result
    GROUP BY
        1
) as tb
ORDER BY tb.timestamp DESC
OFFSET ($1::int - 1) * $2::int
LIMIT
    $2::int
`

type NumResultsOverTimeParams struct {
	PageNumber int32
	PageSize   int32
}

type NumResultsOverTimeRow struct {
	TbTimestamp time.Time
	Count       int64
	FullCount   int64
}

func (q *Queries) NumResultsOverTime(ctx context.Context, arg NumResultsOverTimeParams) ([]NumResultsOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, numResultsOverTime, arg.PageNumber, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NumResultsOverTimeRow
	for rows.Next() {
		var i NumResultsOverTimeRow
		if err := rows.Scan(&i.TbTimestamp, &i.Count, &i.FullCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const numSubmissionsOverTime = `-- name: NumSubmissionsOverTime :many
SELECT tb.timestamp::timestamp, tb.count, tb.full_count
FROM (
    SELECT
        date_trunc('hour', created_at) AS timestamp,
        count(*) AS count,
        count(*) OVER() AS full_count
    FROM
        queue_item
    GROUP BY
        1
) as tb
ORDER BY tb.timestamp DESC 
OFFSET ($1::int - 1) * $2::int
LIMIT
    $2::int
`

type NumSubmissionsOverTimeParams struct {
	PageNumber int32
	PageSize   int32
}

type NumSubmissionsOverTimeRow struct {
	TbTimestamp time.Time
	Count       int64
	FullCount   int64
}

func (q *Queries) NumSubmissionsOverTime(ctx context.Context, arg NumSubmissionsOverTimeParams) ([]NumSubmissionsOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, numSubmissionsOverTime, arg.PageNumber, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NumSubmissionsOverTimeRow
	for rows.Next() {
		var i NumSubmissionsOverTimeRow
		if err := rows.Scan(&i.TbTimestamp, &i.Count, &i.FullCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryMostRecentResultsByKey = `-- name: QueryMostRecentResultsByKey :many
SELECT created_at, value, count(created_at) OVER() AS full_count
FROM result_metadata
JOIN queue_item 
ON result_metadata.queue_item_id=queue_item.id
WHERE result_metadata.type_id = (
    SELECT id FROM result_metadata_type WHERE LOWER(value) = LOWER($1::text)
)
ORDER BY CASE
    WHEN NOT $2::boolean AND $3::text = 'created_at' THEN created_at
END ASC, CASE
    WHEN $2::boolean AND $3::text = 'created_at' THEN created_at
END DESC, value ASC
OFFSET ($4::int - 1) * $5::int
LIMIT  $5::int
`

type QueryMostRecentResultsByKeyParams struct {
	Key        string
	Reverse    bool
	Sort       string
	PageNumber int32
	PageSize   int32
}

type QueryMostRecentResultsByKeyRow struct {
	CreatedAt time.Time
	Value     string
	FullCount int64
}

func (q *Queries) QueryMostRecentResultsByKey(ctx context.Context, arg QueryMostRecentResultsByKeyParams) ([]QueryMostRecentResultsByKeyRow, error) {
	rows, err := q.db.QueryContext(ctx, queryMostRecentResultsByKey,
		arg.Key,
		arg.Reverse,
		arg.Sort,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryMostRecentResultsByKeyRow
	for rows.Next() {
		var i QueryMostRecentResultsByKeyRow
		if err := rows.Scan(&i.CreatedAt, &i.Value, &i.FullCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTopResultsByKey = `-- name: QueryTopResultsByKey :many
SELECT tb.value, tb.count
FROM (
    SELECT result_metadata.value, count(result_metadata.value) as count
    FROM result_metadata
    WHERE result_metadata.type_id = (
        SELECT id FROM result_metadata_type WHERE LOWER(value) = LOWER($1::text)
    )
    GROUP BY result_metadata.value
) as tb
ORDER BY CASE
    WHEN NOT $2::boolean AND $3::text = 'count' THEN count
END ASC, CASE
    WHEN $2::boolean AND $3::text = 'count' THEN count
END DESC, value ASC
OFFSET ($4::int - 1) * $5::int
LIMIT  $5::int
`

type QueryTopResultsByKeyParams struct {
	Key        string
	Reverse    bool
	Sort       string
	PageNumber int32
	PageSize   int32
}

type QueryTopResultsByKeyRow struct {
	Value string
	Count int64
}

func (q *Queries) QueryTopResultsByKey(ctx context.Context, arg QueryTopResultsByKeyParams) ([]QueryTopResultsByKeyRow, error) {
	rows, err := q.db.QueryContext(ctx, queryTopResultsByKey,
		arg.Key,
		arg.Reverse,
		arg.Sort,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTopResultsByKeyRow
	for rows.Next() {
		var i QueryTopResultsByKeyRow
		if err := rows.Scan(&i.Value, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
